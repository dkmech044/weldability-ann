
import numpy as np
import pandas as pd
import joblib
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Input
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau


def main():
    # Load dataset generated by forward_model_full_v23.py
    df = pd.read_csv("ann_dataset_full_v23.csv")
    print("Full dataset shape:", df.shape)

    # Keep only weldable cases
    if "Weldable" not in df.columns:
        raise RuntimeError("Column 'Weldable' not found in ann_dataset_full_v23.csv")
    df_w = df[df["Weldable"] == 1].copy()
    print("Weldable subset shape:", df_w.shape)

    if df_w.shape[0] < 100:
        print("WARNING: Very few weldable samples; inverse mapping will be weak.")

    # Geometry + material as inputs
    feature_cols = [
        "Material_Flag",
        "h1 (mm)",
        "h2 (mm)",
        "h3 (mm)",
    ]

    # Process parameters as outputs
    target_cols = [
        "V1 (m/s)",
        "w_top (mm)",
        "w_bot (mm)",
        "d23 (mm)",
    ]

    for col in feature_cols + target_cols:
        if col not in df_w.columns:
            raise RuntimeError(f"Required column '{col}' not found in dataset.")

    X = df_w[feature_cols].values.astype(np.float32)
    Y = df_w[target_cols].values.astype(np.float32)

    # Scale inputs and outputs
    scaler_X = StandardScaler()
    scaler_Y = StandardScaler()
    Xs = scaler_X.fit_transform(X)
    Ys = scaler_Y.fit_transform(Y)

    joblib.dump(scaler_X, "scaler_X_geom2proc_v23.pkl")
    joblib.dump(scaler_Y, "scaler_Y_geom2proc_v23.pkl")
    print("Saved scaler_X_geom2proc_v23.pkl and scaler_Y_geom2proc_v23.pkl")

    # Train/val split
    X_train, X_val, Y_train, Y_val = train_test_split(
        Xs, Ys, test_size=0.2, random_state=42
    )
    print("Train shape:", X_train.shape, "Val shape:", X_val.shape)

    # Build a small MLP
    model = Sequential([
        Input(shape=(X_train.shape[1],)),
        Dense(64, activation="relu"),
        Dense(64, activation="relu"),
        Dense(32, activation="relu"),
        Dense(Y_train.shape[1], activation="linear"),
    ])

    model.compile(optimizer="adam", loss="mse", metrics=["mae"])

    callbacks = [
        EarlyStopping(
            monitor="val_loss",
            patience=30,
            restore_best_weights=True,
            verbose=1,
        ),
        ReduceLROnPlateau(
            monitor="val_loss",
            patience=10,
            factor=0.5,
            min_lr=1e-5,
            verbose=1,
        ),
    ]

    history = model.fit(
        X_train, Y_train,
        validation_data=(X_val, Y_val),
        epochs=300,
        batch_size=64,
        verbose=2,
        callbacks=callbacks,
    )

    val_loss, val_mae = model.evaluate(X_val, Y_val, verbose=0)
    print(f"Final val_loss (MSE): {val_loss:.4e}, val_MAE: {val_mae:.4e}")

    model.save("weldability_inverse_geom2proc_v23.h5")
    print("Saved weldability_inverse_geom2proc_v23.h5")


if __name__ == "__main__":
    main()
