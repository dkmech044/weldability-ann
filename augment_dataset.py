"""
A) Noise-aware dataset augmentation

This script takes your existing synthetic dataset (generated by the analytical model)
and augments it with (i) experimental-like input noise and (ii) optional batch scatter
(handled upstream if you re-run the analytical generator with perturbed material properties).

Typical usage:
  python augment_dataset.py --in data/base.csv --out data/aug.csv --k 5

You MUST set X_COLS / Y_COLS to match your CSV.

Why this satisfies the reviewer:
- "Augment the dataset with experimental noise, batch variations, or probabilistic simulations."
  Noise augmentation addresses measurement + setup scatter at inference time.
"""
from __future__ import annotations

import argparse
import pandas as pd
import numpy as np
from uq_utils import NoiseSpec, apply_noise

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# EDIT THESE to match your dataset columns
X_COLS = [
    # Example placeholders (replace with your actual HPINN inputs):
    # "Vc12", "Vc23", "beta1", "TI1", "TI2", "mat_flag"
]
Y_COLS = [
    # Example placeholders (replace with your HPINN outputs):
    # "V1", "w_top", "w_bot", "d23", "h1", "h2", "h3"
]
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

# Default noise configuration (you can tune these in the command line by editing the dict)
# Recommendation: choose sigmas comparable to real experimental repeatability.
NOISE_CFG = {
    # Examples:
    # "Vc12": NoiseSpec(mode="absolute", sigma=15.0),   # m/s
    # "Vc23": NoiseSpec(mode="absolute", sigma=15.0),   # m/s
    # "beta1": NoiseSpec(mode="absolute", sigma=0.5),   # deg
    # "TI1":  NoiseSpec(mode="absolute", sigma=25.0),   # K
    # "TI2":  NoiseSpec(mode="absolute", sigma=25.0),   # K
    # "mat_flag": NoiseSpec(mode="absolute", sigma=0.0),  # do not noise discrete flags
}

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--in", dest="inp", required=True, help="Input CSV path")
    ap.add_argument("--out", dest="out", required=True, help="Output CSV path")
    ap.add_argument("--k", type=int, default=5, help="Augmentation multiplier per row")
    ap.add_argument("--seed", type=int, default=7)
    args = ap.parse_args()

    df = pd.read_csv(args.inp)
    assert len(X_COLS) > 0 and len(Y_COLS) > 0, "Set X_COLS and Y_COLS in this script."

    rng = np.random.default_rng(args.seed)

    X = df[X_COLS].to_numpy(dtype=float)
    Y = df[Y_COLS].to_numpy(dtype=float)

    X_aug = []
    Y_aug = []
    for i in range(X.shape[0]):
        xi = X[i:i+1].copy()
        yi = Y[i:i+1].copy()
        # keep original
        X_aug.append(xi)
        Y_aug.append(yi)
        # noisy replicas
        for _ in range(args.k - 1):
            xj = xi.copy()
            for j, col in enumerate(X_COLS):
                spec = NOISE_CFG.get(col, None)
                if spec is None:
                    continue
                xj[:, j] = apply_noise(xj[:, j], spec, rng)
            X_aug.append(xj)
            Y_aug.append(yi)  # label unchanged (noise only on inputs)

    X_aug = np.vstack(X_aug)
    Y_aug = np.vstack(Y_aug)

    out_df = pd.DataFrame(np.hstack([X_aug, Y_aug]), columns=X_COLS + Y_COLS)
    out_df.to_csv(args.out, index=False)
    print(f"Saved augmented dataset: {args.out}  (N={len(out_df)})")

if __name__ == "__main__":
    main()
